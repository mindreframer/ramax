defmodule EventStoreTest do
  use ExUnit.Case, async: true

  alias EventStore
  alias EventStore.Adapters.ETS, as: ETSAdapter
  alias EventStore.Adapters.SQLite, as: SQLiteAdapter

  @moduletag :event_store

  describe "RMX005_4A: EventStore Public API" do
    test "RMX005_4A_T1: new/2 with ETS adapter initializes successfully" do
      table_name = :"test_events_t1_#{:erlang.unique_integer([:positive])}"
      assert {:ok, %EventStore{} = store} = EventStore.new(ETSAdapter, table_name: table_name)
      assert store.adapter == ETSAdapter
      assert is_map(store.adapter_state)
      assert Map.has_key?(store.adapter_state, :events)
      assert Map.has_key?(store.adapter_state, :entity_index)
      assert Map.has_key?(store.adapter_state, :sequence)
    end

    test "RMX005_4A_T2: new/2 with SQLite adapter initializes successfully" do
      db_path = "tmp/test_rmx005_4a_t2.db"
      File.rm(db_path)

      assert {:ok, %EventStore{} = store} = EventStore.new(SQLiteAdapter, database: db_path)
      assert store.adapter == SQLiteAdapter
      assert is_map(store.adapter_state)
      assert Map.has_key?(store.adapter_state, :db)

      # Verify database was created
      assert File.exists?(db_path)

      # Cleanup
      File.rm(db_path)
      File.rm("#{db_path}-shm")
      File.rm("#{db_path}-wal")
    end

    test "RMX005_4A_T3: new/2 returns error on adapter init failure" do
      # Create a fake adapter that fails init
      defmodule FailingAdapter do
        @behaviour EventStore.Adapter

        def init(_opts), do: {:error, :init_failed}

        def append(_state, _space_id, _entity_id, _event_type, _payload, _opts),
          do: {:error, :not_implemented}

        def get_events(_state, _entity_id, _opts), do: {:error, :not_implemented}
        def get_event(_state, _event_id), do: {:error, :not_implemented}
        def get_all_events(_state, _opts), do: {:error, :not_implemented}
        def stream_all_events(_state, _opts), do: []
        def get_latest_sequence(_state), do: {:error, :not_implemented}
        def stream_space_events(_state, _space_id, _opts), do: []
        def get_space_latest_sequence(_state, _space_id), do: {:error, :not_implemented}
      end

      assert {:error, :init_failed} = EventStore.new(FailingAdapter)
    end

    test "RMX005_4A_T4: append/5 updates adapter_state and returns event_id" do
      table_name = :"test_events_t4_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)

      # First append
      {:ok, event_id_1, _space_seq_1, updated_store_1} =
        EventStore.append(
          store,
          "entity:123",
          "entity.created",
          %{name: "Test"}
        )

      assert is_integer(event_id_1)
      assert event_id_1 == 1
      assert %EventStore{} = updated_store_1
      assert updated_store_1.adapter == ETSAdapter
      # Adapter state should be updated (in ETS it stays the same, but struct is new)
      assert is_map(updated_store_1.adapter_state)

      # Second append on updated store
      {:ok, event_id_2, _space_seq_2, updated_store_2} =
        EventStore.append(
          updated_store_1,
          "entity:123",
          "entity.updated",
          %{name: "Updated"}
        )

      assert event_id_2 == 2
      assert %EventStore{} = updated_store_2

      # Verify we can query events
      {:ok, events} = EventStore.get_events(updated_store_2, "entity:123")
      assert length(events) == 2
    end

    test "RMX005_4A_T5: append/5 returns event_id for each event" do
      table_name = :"test_events_t5_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)

      # Append multiple events
      {:ok, id1, _seq1, store} = EventStore.append(store, 1, "entity:1", "event.1", %{data: 1})
      {:ok, id2, _seq2, store} = EventStore.append(store, 1, "entity:1", "event.2", %{data: 2})
      {:ok, id3, _seq3, store} = EventStore.append(store, 1, "entity:1", "event.3", %{data: 3})

      # Event IDs should be sequential
      assert id1 == 1
      assert id2 == 2
      assert id3 == 3

      # Verify all events are stored
      {:ok, events} = EventStore.get_events(store, "entity:1")
      assert length(events) == 3
      assert Enum.map(events, & &1.metadata.event_id) == [1, 2, 3]
    end

    test "RMX005_4A_T6: get_events/3 works with both ETS and SQLite adapters" do
      # Test with ETS
      table_name = :"test_events_t6_ets_#{:erlang.unique_integer([:positive])}"
      {:ok, ets_store} = EventStore.new(ETSAdapter, table_name: table_name)
      {:ok, _id1, ets_store} = EventStore.append(ets_store, "entity:1", "event.1", %{value: "a"})
      {:ok, _id2, ets_store} = EventStore.append(ets_store, "entity:1", "event.2", %{value: "b"})
      {:ok, _id3, ets_store} = EventStore.append(ets_store, "entity:2", "event.3", %{value: "c"})

      {:ok, ets_events} = EventStore.get_events(ets_store, "entity:1")
      assert length(ets_events) == 2
      assert Enum.map(ets_events, & &1.payload.value) == ["a", "b"]

      # Test with SQLite
      db_path = "tmp/test_rmx005_4a_t6_sqlite.db"
      File.rm(db_path)

      {:ok, sqlite_store} = EventStore.new(SQLiteAdapter, database: db_path)

      {:ok, _id1, sqlite_store} =
        EventStore.append(sqlite_store, "entity:1", "event.1", %{value: "a"})

      {:ok, _id2, sqlite_store} =
        EventStore.append(sqlite_store, "entity:1", "event.2", %{value: "b"})

      {:ok, _id3, sqlite_store} =
        EventStore.append(sqlite_store, "entity:2", "event.3", %{value: "c"})

      {:ok, sqlite_events} = EventStore.get_events(sqlite_store, "entity:1")
      assert length(sqlite_events) == 2
      assert Enum.map(sqlite_events, & &1.payload.value) == ["a", "b"]

      # Both adapters should return same structure
      assert Enum.map(ets_events, & &1.metadata.entity_id) ==
               Enum.map(sqlite_events, & &1.metadata.entity_id)

      # Cleanup
      File.rm(db_path)
      File.rm("#{db_path}-shm")
      File.rm("#{db_path}-wal")
    end

    test "RMX005_4A_T7: stream_all_events/2 returns a Stream" do
      table_name = :"test_events_t7_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)

      # Append some events
      {:ok, _id1, _seq1, store} = EventStore.append(store, 1, "entity:1", "event.1", %{value: 1})
      {:ok, _id2, _seq2, store} = EventStore.append(store, 1, "entity:2", "event.2", %{value: 2})
      {:ok, _id3, _seq3, store} = EventStore.append(store, 1, "entity:3", "event.3", %{value: 3})

      # Get stream
      stream = EventStore.stream_all_events(store, batch_size: 2)

      # Verify it's a Stream (it implements the Enumerable protocol)
      assert Enumerable.impl_for(stream) != nil

      # Consume stream - yields individual events, not batches
      all_events = Enum.to_list(stream)
      assert length(all_events) == 3
      assert Enum.map(all_events, & &1.payload.value) == [1, 2, 3]

      # Verify events are in order
      assert Enum.at(all_events, 0).metadata.event_id == 1
      assert Enum.at(all_events, 1).metadata.event_id == 2
      assert Enum.at(all_events, 2).metadata.event_id == 3
    end

    test "RMX005_4A_T8: get_latest_sequence/1 delegation works correctly" do
      table_name = :"test_events_t8_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)

      # Empty store should return 0
      {:ok, seq} = EventStore.get_latest_sequence(store)
      assert seq == 0

      # Append events
      {:ok, _id1, _seq1, store} = EventStore.append(store, 1, "entity:1", "event.1", %{})
      {:ok, _id2, _seq2, store} = EventStore.append(store, 1, "entity:1", "event.2", %{})
      {:ok, _id3, _seq3, store} = EventStore.append(store, 1, "entity:1", "event.3", %{})

      # Should return latest sequence
      {:ok, latest} = EventStore.get_latest_sequence(store)
      assert latest == 3
    end

    test "RMX005_4A_EXTRA_T1: get_event/2 retrieves single event by ID" do
      table_name = :"test_events_extra_1_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)

      {:ok, event_id, _seq, store} =
        EventStore.append(
          store,
          "entity:123",
          "entity.created",
          %{name: "Test Entity"}
        )

      # Get the event by ID
      {:ok, event} = EventStore.get_event(store, event_id)
      assert event.metadata.event_id == event_id
      assert event.metadata.entity_id == "entity:123"
      assert event.metadata.event_type == "entity.created"
      assert event.payload.name == "Test Entity"

      # Try to get non-existent event
      result = EventStore.get_event(store, 99999)
      assert result == {:error, :not_found}
    end

    test "RMX005_4A_EXTRA_T2: get_all_events/2 retrieves all events" do
      table_name = :"test_events_extra_2_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)

      {:ok, _id1, _seq1, store} = EventStore.append(store, 1, "entity:1", "event.1", %{value: "a"})
      {:ok, _id2, _seq2, store} = EventStore.append(store, 1, "entity:2", "event.2", %{value: "b"})
      {:ok, _id3, _seq3, store} = EventStore.append(store, 1, "entity:1", "event.3", %{value: "c"})

      # Get all events
      {:ok, all_events} = EventStore.get_all_events(store)
      assert length(all_events) == 3

      # Should be ordered by event_id
      event_ids = Enum.map(all_events, & &1.metadata.event_id)
      assert event_ids == Enum.sort(event_ids)

      # Test with options
      {:ok, limited_events} = EventStore.get_all_events(store, limit: 2)
      assert length(limited_events) == 2

      {:ok, from_seq_events} = EventStore.get_all_events(store, from_sequence: 1)
      assert length(from_seq_events) == 2
      assert Enum.all?(from_seq_events, fn e -> e.metadata.event_id > 1 end)
    end

    test "RMX005_4A_EXTRA_T3: append with causation_id and correlation_id" do
      table_name = :"test_events_extra_3_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)

      # First event
      {:ok, event_id_1, store} =
        EventStore.append(
          store,
          "entity:123",
          "entity.created",
          %{name: "Test"}
        )

      # Second event caused by first
      {:ok, event_id_2, store} =
        EventStore.append(
          store,
          "entity:123",
          "entity.updated",
          %{name: "Updated"},
          causation_id: event_id_1,
          correlation_id: "batch-123"
        )

      # Verify metadata
      {:ok, event2} = EventStore.get_event(store, event_id_2)
      assert event2.metadata.causation_id == event_id_1
      assert event2.metadata.correlation_id == "batch-123"

      # First event should have auto-generated correlation_id
      {:ok, event1} = EventStore.get_event(store, event_id_1)
      assert is_binary(event1.metadata.correlation_id)
      assert String.length(event1.metadata.correlation_id) > 0
    end

    test "RMX005_4A_EXTRA_T4: events have proper timestamps" do
      table_name = :"test_events_extra_4_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)

      before_time = DateTime.utc_now()
      {:ok, event_id, _seq, store} = EventStore.append(store, 1, "entity:1", "event.1", %{})
      after_time = DateTime.utc_now()

      {:ok, event} = EventStore.get_event(store, event_id)
      timestamp = event.metadata.timestamp

      assert %DateTime{} = timestamp
      assert DateTime.compare(timestamp, before_time) in [:gt, :eq]
      assert DateTime.compare(timestamp, after_time) in [:lt, :eq]
    end

    test "RMX005_4A_EXTRA_T5: adapter state is properly maintained across operations" do
      table_name = :"test_events_extra_5_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)
      initial_state = store.adapter_state

      # Multiple operations
      {:ok, _id1, _seq1, store} = EventStore.append(store, 1, "entity:1", "event.1", %{})
      {:ok, _id2, _seq2, store} = EventStore.append(store, 1, "entity:1", "event.2", %{})
      {:ok, _id3, _seq3, store} = EventStore.append(store, 1, "entity:1", "event.3", %{})

      # State structure should remain consistent
      assert is_map(store.adapter_state)
      assert Map.keys(store.adapter_state) == Map.keys(initial_state)

      # But operations should have effect
      {:ok, events} = EventStore.get_events(store, "entity:1")
      assert length(events) == 3
    end
  end

  describe "RMX007_2A: EventStore Space-Aware API" do
    @tag :skip
    test "RMX007_2_T1: append/6 accepts space_id parameter" do
      # This test will be enabled when adapters implement space support (Phase 3-4)
      table_name = :"test_events_rmx007_t1_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)

      # Append with space_id
      assert {:ok, event_id, space_sequence, updated_store} =
               EventStore.append(
                 store,
                 1,
                 "entity:123",
                 "entity.created",
                 %{name: "Test"}
               )

      assert is_integer(event_id)
      assert is_integer(space_sequence)
      assert %EventStore{} = updated_store
    end

    @tag :skip
    test "RMX007_2_T2: append/6 returns space_sequence" do
      # This test will be enabled when adapters implement space support (Phase 3-4)
      table_name = :"test_events_rmx007_t2_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)

      # First event in space 1
      {:ok, _event_id_1, space_seq_1, store} =
        EventStore.append(store, 1, "entity:1", "event.1", %{})

      # Second event in space 1
      {:ok, _event_id_2, space_seq_2, store} =
        EventStore.append(store, 1, "entity:1", "event.2", %{})

      # First event in space 2
      {:ok, _event_id_3, space_seq_3, _store} =
        EventStore.append(store, 2, "entity:2", "event.3", %{})

      # Space sequences should be independent
      assert space_seq_1 == 1
      assert space_seq_2 == 2
      assert space_seq_3 == 1
    end

    @tag :skip
    test "RMX007_2_T3: stream_space_events/3 delegates to adapter" do
      # This test will be enabled when adapters implement space support (Phase 3-4)
      table_name = :"test_events_rmx007_t3_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)

      # Append events to different spaces
      {:ok, _id1, _seq1, store} = EventStore.append(store, 1, "entity:1", "event.1", %{value: 1})
      {:ok, _id2, _seq2, store} = EventStore.append(store, 1, "entity:1", "event.2", %{value: 2})
      {:ok, _id3, _seq3, store} = EventStore.append(store, 2, "entity:2", "event.3", %{value: 3})

      # Stream space 1 events only
      stream = EventStore.stream_space_events(store, 1)
      events = Enum.to_list(stream)

      assert length(events) == 2
      assert Enum.all?(events, fn e -> e.metadata.space_id == 1 end)
      assert Enum.map(events, & &1.payload.value) == [1, 2]
    end

    @tag :skip
    test "RMX007_2_T4: get_space_latest_sequence/2 delegates to adapter" do
      # This test will be enabled when adapters implement space support (Phase 3-4)
      table_name = :"test_events_rmx007_t4_#{:erlang.unique_integer([:positive])}"
      {:ok, store} = EventStore.new(ETSAdapter, table_name: table_name)

      # Empty space should return 0
      {:ok, seq} = EventStore.get_space_latest_sequence(store, 1)
      assert seq == 0

      # Append events to space 1
      {:ok, _id1, _seq1, store} = EventStore.append(store, 1, "entity:1", "event.1", %{})
      {:ok, _id2, _seq2, store} = EventStore.append(store, 1, "entity:1", "event.2", %{})

      # Should return latest space sequence for space 1
      {:ok, latest} = EventStore.get_space_latest_sequence(store, 1)
      assert latest == 2

      # Space 2 should still be 0
      {:ok, seq2} = EventStore.get_space_latest_sequence(store, 2)
      assert seq2 == 0
    end
  end
end
